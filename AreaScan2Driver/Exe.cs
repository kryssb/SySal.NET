using System;
using SySal;
using System.Runtime.Remoting;
using System.Runtime.Remoting.Channels;
using System.Runtime.Remoting.Channels.Tcp;
using SySal.DAQSystem.Drivers;
using System.Xml;
using System.Xml.Serialization;

namespace SySal.DAQSystem.Drivers.AreaScan2Driver
{
	/// <summary>
	/// Settings for recalibration.
	/// </summary>
	[Serializable]
	public class RecalibrationSettings
	{
		/// <summary>
		/// SQL query text for track selection.
		/// </summary>
		public string SelectionText;
		/// <summary>
		/// Minimum X distance spanned by the recalibration tracks.
		/// </summary>
		public double MinXDistance;
		/// <summary>
		/// Minimum Y distance spanned by the recalibration tracks.
		/// </summary>
		public double MinYDistance;
		/// <summary>
		/// Minimum number of tracks.
		/// </summary>
		public int MinTracks;
		/// <summary>
		/// Recalibration tracks are centered in the field of view by assuming this thickness for the plastic base.
		/// </summary>
		public double BaseThickness;
		/// <summary>
		/// Transverse position tolerance for recalibration.
		/// </summary>
		public double PositionTolerance;
		/// <summary>
		/// Longitudinal position tolerance for recalibration. The actual tolerance is <c>PositionTolerance + Slope * PositionToleranceIncreaseWithSlope</c>.
		/// </summary>
		public double PositionToleranceIncreaseWithSlope;
		/// <summary>
		/// Transverse slope tolerance for recalibration.
		/// </summary>
		public double SlopeTolerance;
		/// <summary>
		/// Longitudinal slope tolerance for recalibration. The actual tolerance is <c>SlopeTolerance + Slope * SlopeToleranceIncreaseWithSlope</c>.
		/// </summary>
		public double SlopeToleranceIncreaseWithSlope;
	}

	/// <summary>
	/// Settings for the data reuse policy.
	/// </summary>
	[Serializable]
	public class ReuseSettings
	{
		/// <summary>
		/// This flag enables/disables data reuse.
		/// </summary>
		public bool Enable;
		/// <summary>
		/// Minimum overlap area between this zone and another zone already in the DB to reuse the latter.
		/// </summary>
		public double MinOverlapArea;
		/// <summary>
		/// Minimum fraction of the total area that overlaps between this zone and another zone already in the DB to reuse the latter.
		/// </summary>
		public double MinOverlapFraction;
		/// <summary>
		/// Maximum area missing if another zone is reused.
		/// </summary>
		public double MaxMissingArea;
		/// <summary>
		/// The list of the program settings in the TB_PROGRAMSETTINGS table whose generated zones are considered compatible with the quality required by this configuration.
		/// When Enable is set to true, data obtained with this same configuration are always considered compatible.
		/// Since the programsettings Id for this configuration is generated by the DB upon program insertion, it can never appear in this list, but it is implicitly included <i>a posteriori</i>.
		/// </summary>
		public long [] ProgramSettingsIds;
	}


	/// <summary>
	/// Data quality settings.
	/// </summary>
	[Serializable]
	public class QualitySettings
	{
		/// <summary>
		/// Minimum density of base-tracks.
		/// </summary>
		public double MinDensityBase;
		/// <summary>
		/// If the scanned zone does not satisfy the quality requirement, it is rescanned, until the quality is satisfactory or this maximum number of trials is reached.
		/// If the maximum number of trials is reached, the zone is in any case written to the DB.
		/// </summary>
		public uint MaxTrials;		
	}

	/// <summary>
	/// Settings from AreaScan2Driver.
	/// </summary>
	[Serializable]
	public class AreaScan2Settings
	{
		/// <summary>
		/// Program settingds Id for the scanning server.
		/// </summary>
		public long ScanningConfigId;
		/// <summary>
		/// Program settings Id for linking.
		/// </summary>
		public long LinkConfigId;
		/// <summary>
		/// Progrsam settings Id for quality cuts.
		/// </summary>
		public long QualityCutId;
		/// <summary>
		/// Recalibration settings.
		/// </summary>
		public RecalibrationSettings Recalibration;
		/// <summary>
		/// Data reuse policy settings.
		/// </summary>
		public ReuseSettings Reuse;
		/// <summary>
		/// Data quality settings.
		/// </summary>
		public QualitySettings Quality;
	}

	/// <summary>
	/// Result of scanning. It includes candidate information, meaningful for recalibration tracks.
	/// </summary>
	public class ScanningResult
	{
		/// <summary>
		/// Recalibration path or volume identifier.
		/// </summary>
		public long PathId;
		/// <summary>
		/// For recalibration tracks, the Id of the candidate.
		/// </summary>
		public long CandidateId;
		/// <summary>
		/// X component of predicted position.
		/// </summary>
		public double PPX;
		/// <summary>
		/// Y component of predicted position.
		/// </summary>
		public double PPY;
		/// <summary>
		/// X component of predicted slope.
		/// </summary>
		public double PSX;
		/// <summary>
		/// Y component of predicted slope.
		/// </summary>
		public double PSY;
		/// <summary>
		/// X component of displacement between found and predicted position.
		/// </summary>
		public double DPX;
		/// <summary>
		/// Y component of displacement between found and predicted position.
		/// </summary>
		public double DPY;
		/// <summary>
		/// X component of misalignment between found and predicted slope.
		/// </summary>
		public double DSX;
		/// <summary>
		/// Y component of misalignment between found and predicted slope.
		/// </summary>
		public double DSY;
	}

	class MyTransformation
	{
		public static void Transform(double X, double Y, ref double tX, ref double tY)
		{
			tX = Transformation.MXX * (X - Transformation.RX) + Transformation.MXY * (Y - Transformation.RY) + Transformation.TX + Transformation.RX;
			tY = Transformation.MYX * (X - Transformation.RX) + Transformation.MYY * (Y - Transformation.RY) + Transformation.TY + Transformation.RY;
		}

		public static void Deform(double X, double Y, ref double dX, ref double dY)
		{
			dX = Transformation.MXX * X + Transformation.MXY * Y;
			dY = Transformation.MYX * X + Transformation.MYY * Y;
		}

		public static SySal.DAQSystem.Scanning.IntercalibrationInfo Transformation = new SySal.DAQSystem.Scanning.IntercalibrationInfo();
	}

    class LinkedZone : SySal.Scanning.Plate.IO.OPERA.LinkedZone
    {
        public class tView : SySal.Scanning.Plate.IO.OPERA.LinkedZone.View
        {
            public tView(SySal.Scanning.Plate.IO.OPERA.LinkedZone.View vw)
            {
                m_Side = vw.Side;
                m_Id = vw.Id;
                m_TopZ = vw.TopZ;
                m_BottomZ = vw.BottomZ;
                MyTransformation.Transform(vw.Position.X, vw.Position.Y, ref m_Position.X, ref m_Position.Y);
            }
        }

        public class tMIPEmulsionTrack : SySal.Scanning.Plate.IO.OPERA.LinkedZone.MIPIndexedEmulsionTrack
        {
            SySal.Scanning.Plate.IO.OPERA.LinkedZone.MIPIndexedEmulsionTrack m_Tk;

            public tMIPEmulsionTrack(SySal.Scanning.Plate.IO.OPERA.LinkedZone.MIPIndexedEmulsionTrack tk) { m_Tk = tk; }

            public override SySal.Tracking.MIPEmulsionTrackInfo Info
            {
                get
                {
                    SySal.Tracking.MIPEmulsionTrackInfo info = m_Tk.Info;
                    MyTransformation.Transform(info.Intercept.X, info.Intercept.Y, ref info.Intercept.X, ref info.Intercept.Y);
                    MyTransformation.Deform(info.Slope.X, info.Slope.Y, ref info.Slope.X, ref info.Slope.Y);
                    return info;
                }
            }

            public override SySal.Scanning.Plate.IO.OPERA.LinkedZone.TrackIndexEntry OriginalRawData
            {
                get
                {
                    return m_Tk.OriginalRawData;
                }
            }

            public override int Id
            {
                get
                {
                    return m_Tk.Id;
                }
            }

            public override SySal.Scanning.Plate.IO.OPERA.LinkedZone.View View
            {
                get
                {
                    return new tView(m_Tk.View);
                }
            }
        }

        public class tMIPBaseTrack : SySal.Scanning.MIPBaseTrack
        {
            SySal.Scanning.MIPBaseTrack m_Tk;

            public tMIPBaseTrack(SySal.Scanning.MIPBaseTrack tk) { m_Tk = tk; m_Id = m_Tk.Id; }

            public override SySal.Tracking.MIPEmulsionTrackInfo Info
            {
                get
                {
                    SySal.Tracking.MIPEmulsionTrackInfo info = m_Tk.Info;
                    MyTransformation.Transform(info.Intercept.X, info.Intercept.Y, ref info.Intercept.X, ref info.Intercept.Y);
                    MyTransformation.Deform(info.Slope.X, info.Slope.Y, ref info.Slope.X, ref info.Slope.Y);
                    return info;
                }
            }

            public override SySal.Scanning.MIPIndexedEmulsionTrack Top
            {
                get
                {
                    return new tMIPEmulsionTrack((SySal.Scanning.Plate.IO.OPERA.LinkedZone.MIPIndexedEmulsionTrack)m_Tk.Top);
                }
            }

            public override SySal.Scanning.MIPIndexedEmulsionTrack Bottom
            {
                get
                {
                    return new tMIPEmulsionTrack((SySal.Scanning.Plate.IO.OPERA.LinkedZone.MIPIndexedEmulsionTrack)m_Tk.Bottom);
                }
            }
        }

        public class tSide : SySal.Scanning.Plate.IO.OPERA.LinkedZone.Side
        {
            SySal.Scanning.Plate.Side m_Side;

            public tSide(SySal.Scanning.Plate.Side sd)
            {
                m_Side = sd;
                m_TopZ = sd.TopZ;
                m_BottomZ = sd.BottomZ;
            }

            public override int Length { get { return m_Side.Length; } }

            public override SySal.Scanning.MIPIndexedEmulsionTrack this[int index] { get { return new tMIPEmulsionTrack((SySal.Scanning.Plate.IO.OPERA.LinkedZone.MIPIndexedEmulsionTrack)(m_Side[index])); } }

            public override SySal.Scanning.Plate.IO.OPERA.LinkedZone.View View(int id) { return new tView(((SySal.Scanning.Plate.IO.OPERA.LinkedZone.Side)m_Side).View(id)); }

            public override int ViewCount { get { return ((SySal.Scanning.Plate.IO.OPERA.LinkedZone.Side)m_Side).ViewCount; } }
        }

        SySal.Scanning.Plate.IO.OPERA.LinkedZone m_LZ;

        public LinkedZone(SySal.Scanning.Plate.IO.OPERA.LinkedZone lz)
        {
            m_LZ = lz;
            MyTransformation.Transform(lz.Extents.MinX, lz.Extents.MinY, ref m_Extents.MinX, ref m_Extents.MinY);
            MyTransformation.Transform(lz.Extents.MaxX, lz.Extents.MaxY, ref m_Extents.MaxX, ref m_Extents.MaxY);
            MyTransformation.Transform(lz.Center.X, lz.Center.Y, ref m_Center.X, ref m_Center.Y);
            m_Id = lz.Id;
            m_Top = new tSide(lz.Top);
            m_Bottom = new tSide(lz.Bottom);
            SySal.DAQSystem.Scanning.IntercalibrationInfo otr = lz.Transform;
            SySal.DAQSystem.Scanning.IntercalibrationInfo tr = new SySal.DAQSystem.Scanning.IntercalibrationInfo();
            tr.MXX = MyTransformation.Transformation.MXX * otr.MXX + MyTransformation.Transformation.MXY * otr.MYX;
            tr.MXY = MyTransformation.Transformation.MXX * otr.MXY + MyTransformation.Transformation.MXY * otr.MYY;
            tr.MYX = MyTransformation.Transformation.MYX * otr.MXX + MyTransformation.Transformation.MYY * otr.MYX;
            tr.MYY = MyTransformation.Transformation.MYX * otr.MXY + MyTransformation.Transformation.MYY * otr.MYY;
            tr.RX = MyTransformation.Transformation.RX;
            tr.RY = MyTransformation.Transformation.RY;
            tr.TZ = MyTransformation.Transformation.TZ + otr.TZ;
            tr.TX = (tr.MXX - MyTransformation.Transformation.MXX) * (MyTransformation.Transformation.RX - otr.RX) + (tr.MXY - MyTransformation.Transformation.MXY) * (MyTransformation.Transformation.RY - otr.RY) + MyTransformation.Transformation.MXX * otr.TX + MyTransformation.Transformation.MXY * otr.TY + MyTransformation.Transformation.TX;
            tr.TY = (tr.MYX - MyTransformation.Transformation.MYX) * (MyTransformation.Transformation.RX - otr.RX) + (tr.MYY - MyTransformation.Transformation.MYY) * (MyTransformation.Transformation.RY - otr.RY) + MyTransformation.Transformation.MYX * otr.TX + MyTransformation.Transformation.MYY * otr.TY + MyTransformation.Transformation.TY;
            m_Transform = tr;
        }

        public override int Length
        {
            get
            {
                return m_LZ.Length;
            }
        }

        public override SySal.Scanning.MIPBaseTrack this[int index]
        {
            get
            {
                return new tMIPBaseTrack(m_LZ[index]);
            }
        }
    }

	/// <summary>
	/// AreaScan2Driver executor.
	/// </summary>
	/// <remarks>
	/// <para>AreaScan2Driver scans areas in a plate, checking data quality, and optionally reusing old data.</para>
	/// <para>All input and output come from the DB. Areas are read from TB_VOLUME_SLICES and results are written to the same table.</para>
	/// <para>
	/// Before real scanning, a recalibration can be computed using "safe" tracks.
	/// The selection must return the following columns, in this order:
	/// <c>POSX POSY SLOPEX SLOPEY</c>
	/// </para>
	/// <para>
	/// <c>_BRICK_</c> will be replaced with the brick ID.
	/// <c>_PLATE_</c> will be replaced with the plate ID.
	/// </para>
	/// <para>
	/// Supported Interrupts:
	/// <list type="bullet">
	/// <item>
	/// <description><c>IgnoreScanFailure False|True</c> instructs AreaScan2Driver to stop on failed zones or to skip them and go on.</description>
	/// </item>
	/// <item>
	/// <description><c>IgnoreRecalFailure False|True</c> instructs AreaScan2Driver to stop on failed recalibration tracks or to skip them and go on.</description>
	/// </item>
	/// </list>
	/// Type: <c>AreaScan2Driver /EasyInterrupt</c> for a graphical user interface to send interrupts.
	/// </para>
	/// <para>
	/// The following substitutions apply:
	/// <list type="table">
	/// <item><term><c>%EXEREP%</c></term><description>Executable repository path specified in the Startup file.</description></item>
	/// <item><term><c>%RWDDIR%</c></term><description>Output directory for Raw Data.</description></item>
	/// <item><term><c>%TLGDIR%</c></term><description>Output directory for linked zones.</description></item>
	/// <item><term><c>%RWD%</c></term><description>Scanning output file name (not including extension).</description></item>
	/// <item><term><c>%TLG%</c></term><description>Linked zone file name (not including extension).</description></item>
	/// <item><term><c>%SCRATCH%</c></term><description>Scratch directory specified in the Startup file.</description></item>
	/// <item><term><c>%ZONEID%</c></term><description>Hexadecimal file name for a zone.</description></item>
	/// </list>
	/// </para>
	/// <para>
	/// A sample XML configuration for AreaScan2Driver follows:
	/// <example>
	/// <code>
	/// &lt;AreaScan2Settings&gt;
	///  &lt;ScanningConfigId&gt;105382855&lt;/ScanningConfigId&gt;
	///  &lt;LinkConfigId&gt;108888238&lt;/LinkConfigId&gt;
	///  &lt;QualityCutId&gt;108382880&lt;/QualityCutId&gt;
	///  &lt;Recalibration&gt;
	///   &lt;SelectionText&gt;select POSX, POSY, SLOPEX, SLOPEY from (select ID_ZONE, POSX, POSY, SLOPEX, SLOPEY, ROW_NUMBER() OVER (PARTITION BY ID_ZONE ORDER BY ID) AS RNUM from TB_MIPBASETRACKS where ID_EVENTBRICK = _BRICK_ and ID_ZONE in (select ID from TB_ZONES where ID_EVENTBRICK = _BRICK_ and ID_PROCESSOPERATION in (select CALIBRATION from VW_PLATES where ID_EVENTBRICK = _BRICK_ and ID = _PLATE_)) and GRAINS &amp;gt; 27 and SQRT(SLOPEX*SLOPEX+SLOPEY*SLOPEY) &amp;lt; 0.25 and SQRT(SLOPEX*SLOPEX+SLOPEY*SLOPEY) &amp;gt; 0.05) where RNUM &amp;lt;= 5&lt;/SelectionText&gt;
	///   &lt;MinXDistance&gt;30000&lt;/MinXDistance&gt;
	///   &lt;MinYDistance&gt;30000&lt;/MinYDistance&gt;
	///   &lt;MinTracks&gt;8&lt;/MinTracks&gt;
	///   &lt;BaseThickness&gt;210&lt;/BaseThickness&gt;
	///   &lt;PositionTolerance&gt;60&lt;/PositionTolerance&gt;
	///   &lt;PositionToleranceIncreaseWithSlope&gt;6&lt;/PositionToleranceIncreaseWithSlope&gt;
	///   &lt;SlopeTolerance&gt;0.03&lt;/SlopeTolerance&gt;
	///   &lt;SlopeToleranceIncreaseWithSlope&gt;0.3&lt;/SlopeToleranceIncreaseWithSlope&gt;
	///  &lt;/Recalibration&gt;
	///  &lt;Reuse&gt;
	///   &lt;Enable&gt;true&lt;/Enable&gt;
	///   &lt;MinOverlapArea&gt;16000000&lt;/MinOverlapArea&gt;
	///   &lt;MinOverlapFraction&gt;0.95&lt;/MinOverlapFraction&gt;
	///   &lt;MaxMissingArea&gt;100000&lt;/MaxMissingArea&gt;
	///   &lt;ProgramSettingsIds&gt;
	///    &lt;long&gt;183288&lt;/long&gt;
	///    &lt;long&gt;164734&lt;/long&gt;
	///    &lt;long&gt;136829&lt;/long&gt;
	///   &lt;/ProgramSettingsIds&gt;
	///  &lt;/Reuse&gt;
	///  &lt;Quality&gt;
	///   &lt;MinDensityBase&gt;4E-05&lt;/MinDensityBase&gt;
	///   &lt;MaxTrials&gt;2&lt;/MaxTrials&gt;
	///  &lt;/Quality&gt;
	/// &lt;/AreaScan2Settings&gt;	
	/// </code>
	/// </example>
	/// </para>
	/// <para><b>NOTICE: If the quality cut id is identical to the linker id, no quality cut is applied (unless the linker applies its own quality cuts).</b></para>
	/// </remarks>	
    public class Exe : MarshalByRefObject, IInterruptNotifier, SySal.Web.IWebApplication
	{
		/// <summary>
		/// Initializes the Lifetime Service.
		/// </summary>
		/// <returns>the lifetime service object or null.</returns>
		public override object InitializeLifetimeService()
		{
			return null;	
		}

		const int ScanFailed = -5;

		static void ShowExplanation()
		{
			ExplanationForm EF = new ExplanationForm();
			System.IO.StringWriter strw = new System.IO.StringWriter();
			strw.WriteLine("");
			strw.WriteLine("AreaScan2Driver");
			strw.WriteLine("--------------");
			strw.WriteLine("AreaScan2Driver scans areas in a plate, checking data quality, and optionally reusing old data.");
			strw.WriteLine("");
			strw.WriteLine("All input and output come from the DB. Areas are read from TB_VOLUME_SLICES and results are written to the same table.");		
			strw.WriteLine("Before real scanning, a recalibration is computed using \"safe\" tracks.");
			strw.WriteLine("The selection must return the following columns, in this order:");
			strw.WriteLine();
			strw.WriteLine("POSX\tPOSY\tSLOPEX\tSLOPEY");
			strw.WriteLine("_BRICK_ will be replaced with the brick ID");
			strw.WriteLine("_PLATE_ will be replaced with the plate ID");
			strw.WriteLine();
			strw.WriteLine("Type: AreaScan2Driver /Interrupt <batchmanager> <process operation id> <interrupt string>");
			strw.WriteLine("to send an interrupt message to a running AreaScan2Driver process operation.");
			strw.WriteLine("SUPPORTED INTERRUPTS:");
			strw.WriteLine("IgnoreScanFailure False|True - instructs AreaScan2Driver to stop on failed zones or skip them and go on.");
			strw.WriteLine("IgnoreRecalFailure False|True - instructs AreaScan2Driver to stop on failed recalibration tracks or skip them and go on.");
			strw.WriteLine("Type: AreaScan2Driver /EasyInterrupt for a graphical user interface to send interrupts.");			
			strw.WriteLine("--------------");
			strw.WriteLine("The following substitutions apply (case is disregarded):");
			strw.WriteLine("%EXEREP% = Executable repository path specified in the Startup file.");
			strw.WriteLine("%RWDDIR% = Output directory for Raw Data.");
			strw.WriteLine("%TLGDIR% = Output directory for linked zones.");
			strw.WriteLine("%RWD% = Scanning output file name (not including extension).");
			strw.WriteLine("%TLG% = Linked zone file name (not including extension).");
			strw.WriteLine("%SCRATCH% = Scratch directory specified in the Startup file.");			
			strw.WriteLine("%ZONEID% = Hexadecimal file name for a zone.");
			strw.WriteLine("--------------");
			strw.WriteLine("The program settings should have the following structure:");
			AreaScan2Settings pset = new AreaScan2Settings();
			pset.LinkConfigId = 108888238;
			pset.QualityCutId = 108382880;
			pset.ScanningConfigId = 105382855;
			pset.Recalibration = new RecalibrationSettings();
			pset.Quality = new QualitySettings();
			pset.Reuse = new ReuseSettings();
			pset.Recalibration.BaseThickness = 210.0;
			pset.Recalibration.MinTracks = 8;
			pset.Recalibration.MinXDistance = 30000.0;
			pset.Recalibration.MinYDistance = 30000.0;
			pset.Recalibration.PositionTolerance = 60.0;
			pset.Recalibration.PositionToleranceIncreaseWithSlope = 6.0;
			pset.Recalibration.SlopeTolerance = 0.03;
			pset.Recalibration.SlopeToleranceIncreaseWithSlope = 0.3;
			pset.Recalibration.SelectionText = "select POSX, POSY, SLOPEX, SLOPEY from (select ID_ZONE, POSX, POSY, SLOPEX, SLOPEY, ROW_NUMBER() OVER (PARTITION BY ID_ZONE ORDER BY ID) AS RNUM from " +
				"TB_MIPBASETRACKS where ID_EVENTBRICK = _BRICK_ and ID_ZONE in (select ID from TB_ZONES where ID_EVENTBRICK = _BRICK_ and ID_PROCESSOPERATION in " +
				"(select CALIBRATION from VW_PLATES where ID_EVENTBRICK = _BRICK_ and ID = _PLATE_)) and GRAINS > 27 and " +
				"SQRT(SLOPEX*SLOPEX+SLOPEY*SLOPEY) < 0.25 and SQRT(SLOPEX*SLOPEX+SLOPEY*SLOPEY) > 0.05) where RNUM <= 5";
			pset.Quality.MaxTrials = 2;
			pset.Quality.MinDensityBase = 0.00004;
			pset.Reuse.Enable = true;
			pset.Reuse.MaxMissingArea = 100000.0;
			pset.Reuse.MinOverlapArea = 16000000.0;
			pset.Reuse.MinOverlapFraction = 0.95;
			pset.Reuse.ProgramSettingsIds = new long [3] {183288, 164734, 136829};									
			new System.Xml.Serialization.XmlSerializer(typeof(AreaScan2Settings)).Serialize(strw, pset);
			strw.WriteLine("");
			strw.WriteLine("");
			strw.WriteLine("NOTICE: If the quality cut id is identical to the linker id, no quality cut is applied (unless the linker applies its own quality cuts).");
			EF.RTFOut.Text = strw.ToString();
			EF.ShowDialog();			
		}
		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		[STAThread]
		internal static void Main(string[] args)
		{
			HE = SySal.DAQSystem.Drivers.HostEnv.Own;
			if (HE == null)
			{
                if (args.Length == 4 && String.Compare(args[0].Trim(), "/Interrupt", true) == 0) SendInterrupt(args[1], Convert.ToInt64(args[2]), args[3]);
				else if (args.Length == 1 && String.Compare(args[0].Trim(), "/EasyInterrupt", true) == 0) EasyInterrupt();
				else ShowExplanation();
				return;
			}
			Execute();
		}

        private static void SendInterrupt(string machine, long op, string interruptdata)
        {
            SySal.OperaDb.OperaDbCredentials cred = SySal.OperaDb.OperaDbCredentials.CreateFromRecord();
            SySal.OperaDb.OperaDbConnection conn = cred.Connect();
            conn.Open();
            string addr = new SySal.OperaDb.OperaDbCommand("SELECT ADDRESS FROM TB_MACHINES WHERE ID = '" + machine + "' OR UPPER(NAME) = '" + machine.ToUpper() + "' OR UPPER(ADDRESS) = '" + machine.ToUpper() + "' AND ISBATCHSERVER <> 0", conn).ExecuteScalar().ToString();
            Console.WriteLine("Contacting Batch Manager " + addr);
            ((SySal.DAQSystem.BatchManager)System.Runtime.Remoting.RemotingServices.Connect(typeof(SySal.DAQSystem.BatchManager), "tcp://" + addr + ":" + ((int)SySal.DAQSystem.OperaPort.BatchServer) + "/BatchManager.rem")).Interrupt(op, cred.OPERAUserName, cred.OPERAPassword, interruptdata);
        }

		private static SySal.DAQSystem.Drivers.HostEnv HE = null;

		private static SySal.OperaDb.OperaDbConnection Conn = null;

		private static SySal.OperaDb.OperaDbTransaction Trans = null;

		private static AreaScan2Settings ProgSettings;

		private static string QualityCut;

		private static string LinkConfig;

		private static object QualityCutExe;

		private static object LinkerExe;

		private static SySal.DAQSystem.Drivers.ScanningStartupInfo StartupInfo;

		private static SySal.DAQSystem.Drivers.TaskProgressInfo ProgressInfo = null;

		private static SySal.DAQSystem.ScanServer ScanSrv;

		private static SySal.DAQSystem.IDataProcessingServer DataProcSrv;

		private static int TotalZones = 0;

		private static SySal.DAQSystem.Scanning.IntercalibrationInfo DirRecal = new SySal.DAQSystem.Scanning.IntercalibrationInfo();

		private static SySal.DAQSystem.Scanning.IntercalibrationInfo InvRecal = new SySal.DAQSystem.Scanning.IntercalibrationInfo();

		private static bool RecalibrationDone = false;

		private static int RecalibrationTracksToScan = 0;

		private static System.Threading.ManualResetEvent ProcessEvent = new System.Threading.ManualResetEvent(true);

		private static System.Threading.AutoResetEvent RecalEvent = new System.Threading.AutoResetEvent(false);

		private static System.Collections.ArrayList ScanQueue = new System.Collections.ArrayList();		

		private static System.Collections.Queue ReuseQueue = new System.Collections.Queue();

		private static System.Threading.Thread ThisThread = null;

		private static System.Threading.Thread WorkerThread = new System.Threading.Thread(new System.Threading.ThreadStart(WorkerThreadExec));

		private static System.Collections.Queue WorkQueue = new System.Collections.Queue();

        private static System.Threading.Thread DBKeepAliveThread = null;

        private static void DBKeepAliveThreadExec()
        {
            try
            {
                SySal.OperaDb.OperaDbCommand keepalivecmd = null;
                lock (Conn)
                    keepalivecmd = new SySal.OperaDb.OperaDbCommand("SELECT COUNT(*) FROM DUAL", Conn);
                while (Conn != null)
                {
                    keepalivecmd.ExecuteScalar();
                    System.Threading.Thread.Sleep(10000);
                }
            }
            catch (System.Threading.ThreadAbortException)
            {
                System.Threading.Thread.ResetAbort();
            }
            catch (Exception) { }
        }

		private static void WorkerThreadExec()
		{
            try
            {
                while (true)
                {
                    int qc;
                    try
                    {
                        System.Threading.Thread.Sleep(System.Threading.Timeout.Infinite);
                    }
                    catch (System.Threading.ThreadInterruptedException) { }
                    lock (ReuseQueue)
                        if (ReuseQueue.Count > 0)
                            Reuse();
                        else
                        {
                            lock (WorkQueue)
                                if ((qc = WorkQueue.Count) == 0) return;
                            while (qc > 0)
                            {
                                PostProcess();
                                lock (WorkQueue) qc = WorkQueue.Count;
                            }
                        }
                }
            }
            catch (System.Threading.ThreadAbortException)
            {
                System.Threading.Thread.ResetAbort();
            }
            catch (Exception) { }
		}

		private static System.Exception ThisException = null;

		private static bool IgnoreScanFailure = false;

		private static bool IgnoreRecalFailure = true;

		private static System.Collections.ArrayList ScanningResults = new System.Collections.ArrayList();

		private static System.Collections.ArrayList RecalibrationResults = new System.Collections.ArrayList();

		private static System.Collections.ArrayList RecoveredZones = new System.Collections.ArrayList();

		private static System.Drawing.Bitmap gIm = null;
		
		private static System.Drawing.Graphics gMon = null;

		private static NumericalTools.Plot gPlot = null;

		private static bool IsFirstPlot = true;

		private static void EasyInterrupt()
		{
			(new frmEasyInterrupt()).ShowDialog();
		}

		private delegate void dPostProcess();

		private static void Reuse()
		{			
			long xid = 0;
			try
			{
				while (ReuseQueue.Count > 0)
				{				
					SySal.DAQSystem.Drivers.Prediction zd = (SySal.DAQSystem.Drivers.Prediction)ReuseQueue.Dequeue();					
					xid = zd.Series;
					if (ReuseZone(zd) == 0)
						lock(ScanQueue)
							ScanQueue.Add(zd);							
					else UpdateProgress();
				}				
				ThisException = null;
				ProcessEvent.Set();
			}
			catch (Exception x)
			{
				try
				{
					HE.WriteLine("Error while trying to reuse zone " + xid + "\r\n" + x.ToString());
					UpdateProgress();
				}
				catch (Exception) {}
				ThisException = x;
				ProcessEvent.Set();
				RecalEvent.Set();

			}
		}

		private static void PostProcess()
		{			        
			try
			{
				while (true)
				{
					bool Recovered = false;
					Prediction zd = null;
					lock(ScanQueue)
					{
						if (WorkQueue.Count == 0)
						{
							ThisException = null;
							ProcessEvent.Set();
							break;
						}
						zd = (Prediction)WorkQueue.Dequeue();
					}
					long xid = 0;

					string corrfile = "";
					if (System.IO.File.Exists(StartupInfo.ScratchDir + @"\fragmentshiftcorrection_" + StartupInfo.MachineId + ".xml"))
						corrfile = " " + StartupInfo.ScratchDir + @"\fragmentshiftcorrection_" + StartupInfo.MachineId + ".xml";

					System.Globalization.CultureInfo InvC = System.Globalization.CultureInfo.InvariantCulture;

					SySal.Scanning.Plate.IO.OPERA.LinkedZone lz = null;
					SySal.DAQSystem.DataProcessingBatchDesc dbd = new SySal.DAQSystem.DataProcessingBatchDesc();

					xid = zd.Series;
					ScanningResult res = new ScanningResult();
					res.PathId = zd.Series;
					res.CandidateId = 0;
					res.PPX = zd.PredictedPosX;
					res.PPY = zd.PredictedPosY;
					res.PSX = zd.PredictedSlopeX;
					res.PSY = zd.PredictedSlopeY;
					res.DPX = 0.0;
					res.DPY = 0.0;
					res.DSX = 0.0;
					res.DSY = 0.0;						
					HE.Write("Processing " + zd.Series + ": ...");

					if (zd.Series > 0)
					{
						if (RecoveredZones.BinarySearch(zd.Series) >= 0)
						{
							//lz = (SySal.Scanning.Plate.IO.OPERA.LinkedZone)OperaPersistence.Restore(zd.Outname + ".tlg", typeof(SySal.Scanning.Plate.IO.OPERA.LinkedZone));
                            lz = new SySal.DataStreams.OPERALinkedZone(zd.Outname + ".tlg");
							Recovered = true;
						}
						else if (zd.CandidateIndex != ScanFailed)
						{
							dbd.AliasUsername = StartupInfo.DBUserName;
							dbd.AliasPassword = StartupInfo.DBPassword;
							dbd.Description = "Link for AreaScan2Driver B#" + StartupInfo.Plate.BrickId + " P#" + StartupInfo.Plate.PlateId + " V#" + zd.Series;
							dbd.Id = DataProcSrv.SuggestId;
							dbd.Token = HE.Token;
							dbd.MachinePowerClass = 5;
							dbd.Filename = StartupInfo.ExeRepository + @"\BatchLink.exe";
							dbd.CommandLineArguments = "/wait " + zd.Outname + ".rwc " + zd.Outname + ".tlg db:\\" + ProgSettings.LinkConfigId + ".xml" + corrfile;
                            dbd.OutputTextSaveFile = zd.Outname + ".link.log";
							if (!DataProcSrv.Enqueue(dbd)) throw new Exception("Cannot schedule linking batch " + dbd.Id + " for " + zd.Outname + ". Aborting.");
                            while (DataProcSrv.DoneWith(dbd.Id) == false) System.Threading.Thread.Sleep(100);
							dbd = DataProcSrv.Result(dbd.Id);
							
							if (ProgSettings.LinkConfigId != ProgSettings.QualityCutId)
							{
								dbd.AliasUsername = StartupInfo.DBUserName;
								dbd.AliasPassword = StartupInfo.DBPassword;
								dbd.Description = "Quality cut for AreaScan2Driver B#" + StartupInfo.Plate.BrickId + " P#" + StartupInfo.Plate.PlateId + " V#" + zd.Series;
								dbd.Id = DataProcSrv.SuggestId;
								dbd.Token = HE.Token;
								dbd.MachinePowerClass = 5;
								dbd.Filename = StartupInfo.ExeRepository + @"\TLGSel.exe";
								dbd.CommandLineArguments = zd.Outname + ".tlg " + zd.Outname + ".tlg \"" + QualityCut + "\"";
                                dbd.OutputTextSaveFile = zd.Outname + ".sel.log";
								if (!DataProcSrv.Enqueue(dbd)) throw new Exception("Cannot schedule quality cut batch " + dbd.Id + " for " + zd.Outname + ". Aborting.");
								while (DataProcSrv.DoneWith(dbd.Id) == false) System.Threading.Thread.Sleep(100);
								dbd = DataProcSrv.Result(dbd.Id);
							}
							//lz = (SySal.Scanning.Plate.IO.OPERA.LinkedZone)OperaPersistence.Restore(zd.Outname + ".tlg", typeof(SySal.Scanning.Plate.IO.OPERA.LinkedZone));
                            lz = new SySal.DataStreams.OPERALinkedZone(zd.Outname + ".tlg");
						}
					}
					else
					{
						if (zd.CandidateIndex != ScanFailed)
						{
							lz = (SySal.Scanning.Plate.IO.OPERA.LinkedZone)(LinkerExe.GetType().InvokeMember("ProcessData", System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.InvokeMethod | System.Reflection.BindingFlags.Instance, null, LinkerExe, new object[4] {ReplaceStrings(zd.Outname + ".rwc", zd.Series, ""), null, LinkConfig, null}));
							if (QualityCutExe != null) lz = (SySal.Scanning.Plate.IO.OPERA.LinkedZone)(QualityCutExe.GetType().InvokeMember("ProcessData", System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.InvokeMethod | System.Reflection.BindingFlags.Instance, null, QualityCutExe, new object[3] {lz, QualityCut, false}));
						}
					}
					if (zd.CandidateIndex == ScanFailed) lz = null;
					else if (RecalibrationDone) lz = new LinkedZone(lz);

					res = null;
					if (zd.Series < 0)
					{
						if (zd.CandidateIndex == ScanFailed)
						{
							zd.CandidateIndex = 0;
							zd.MaxTrials = 1;
						}
						else
						{
							int t = 0;
							zd.CandidateIndex = 0;
							zd.CandidateInfo = null;
							double nx, ny;
							double slope = Math.Sqrt(zd.PredictedSlopeX * zd.PredictedSlopeX + zd.PredictedSlopeY * zd.PredictedSlopeY);
							if (slope > 0.0)
							{
								nx = zd.PredictedSlopeX / slope;
								ny = zd.PredictedSlopeY / slope;
							}
							else
							{
								nx = 1.0;
								ny = 0.0;
							}
							double slopelng = ProgSettings.Recalibration.SlopeTolerance + ProgSettings.Recalibration.SlopeToleranceIncreaseWithSlope * slope;
							double poslng = ProgSettings.Recalibration.PositionTolerance + ProgSettings.Recalibration.PositionToleranceIncreaseWithSlope * slope;
							double dpos = 10.0;
							double dpx = 0.0, dpy = 0.0, dsx = 0.0, dsy = 0.0, dpc, dp = 0.0;
							zd.CandidateIndex = 0;
							zd.CandidateInfo = null;
							res = new ScanningResult();
							res.PathId = zd.Series;
							res.CandidateId = 0;
							res.PPX = zd.PredictedPosX;
							res.PPY = zd.PredictedPosY;
							res.PSX = zd.PredictedSlopeX;
							res.PSY = zd.PredictedSlopeY;
							res.DPX = 0.0;
							res.DPY = 0.0;
							res.DSX = 0.0;
							res.DSY = 0.0;						
							for (t = 0; t < lz.Length; t++)
							{
								SySal.Tracking.MIPEmulsionTrackInfo info = lz[t].Info;
								dsx = info.Slope.X - zd.PredictedSlopeX;
								dsy = info.Slope.Y - zd.PredictedSlopeY;
								if (Math.Abs(dsx * ny - dsy * nx) > ProgSettings.Recalibration.SlopeTolerance) continue;
								if (Math.Abs(dsx * nx + dsy * ny) > slopelng) continue;
								dpx = info.Intercept.X - zd.PredictedPosX;
								dpy = info.Intercept.Y - zd.PredictedPosY;
								dpc = (dpx * nx + dpy * ny) / poslng;
								if (Math.Abs(dpc) > 1.0) continue;
								dp = dpc * dpc;
								dpc = (dpx * ny - dpy * nx) / ProgSettings.Recalibration.PositionTolerance;
								if (Math.Abs(dpc) > 1.0) continue;
								dp += dpc * dpc;
								if (dp < dpos)
								{
									dpos = dp;
									zd.CandidateIndex = t + 1;
									zd.CandidateInfo = info;
									res.CandidateId = zd.CandidateIndex;
									res.DPX = dpx;
									res.DPY = dpy;
									res.DSX = dsx;
									res.DSY = dsy;
								}
							}
						}
						if (zd.CandidateIndex == 0)
						{
							if (--zd.MaxTrials > 0)
							{
								HE.WriteLine(" Not found, trials to go: " + zd.MaxTrials);
								string [] rwds = System.IO.Directory.GetFiles(zd.Outname.Substring(0, zd.Outname.LastIndexOf("\\")), zd.Outname.Substring(zd.Outname.LastIndexOf("\\") + 1) + ".rwd.*");
								foreach (string rwd in rwds)
									System.IO.File.Delete(rwd);
								System.IO.File.Delete(zd.Outname + ".rwc");
								lock(ScanQueue)
								{
									if (ScanQueue.Count >= 2)
										ScanQueue.Insert(2, zd);
									else 
										ScanQueue.Add(zd);									
								}						
								UpdateProgress();
							}
							else
							{
								HE.WriteLine(" Not found, abandoned.");
								lock(ScanQueue)
								{
									RecalibrationResults.Add(res);
									RecalibrationTracksToScan--;
									if (RecalibrationTracksToScan == 0)
									{
										if (!RecalibrationDone) ComputeRecalibration();
										ThisException = null;
										RecalEvent.Set();
									}
								}
							}
						}
						else
						{

							HE.WriteLine(" Found.");
							lock(ScanQueue)
							{
								RecalibrationResults.Add(res);
								RecalibrationTracksToScan--;
								if (RecalibrationTracksToScan == 0)
								{
									if (!RecalibrationDone) ComputeRecalibration();
									ThisException = null;
									RecalEvent.Set();
								}
							}
						}
					}
					else
					{
						if ((zd.CandidateIndex == ScanFailed || CheckQuality(zd, lz) == false) && --zd.MaxTrials > 0)
						{
							HE.WriteLine(" Insufficient quality, trials to go: " + zd.MaxTrials);
							string [] rwds = System.IO.Directory.GetFiles(zd.Outname.Substring(0, zd.Outname.LastIndexOf("\\")), zd.Outname.Substring(zd.Outname.LastIndexOf("\\") + 1) + ".rwd.*");
							foreach (string rwd in rwds)
								System.IO.File.Delete(rwd);
							System.IO.File.Delete(zd.Outname + ".rwc");
							lock(ScanQueue)
							{
								if (ScanQueue.Count >= 2)
									ScanQueue.Insert(2, zd);
								else 
									ScanQueue.Add(zd);									
							}						
							UpdateProgress();
						}
						else
						{
							res = new ScanningResult();
							res.PathId = zd.Series;
							res.CandidateId = 0;
							WriteResult(zd, res, lz);
							int index = RecoveredZones.BinarySearch(res.PathId);
							if (index < 0)
								RecoveredZones.Insert(~index, res.PathId);							
							UpdateProgress();
						}
					}
					UpdatePlots();
					xid = 0;
					lz = null;						
				}								
			}
			catch (Exception x)
			{
				try
				{
					HE.WriteLine("Exception:\r\n" + x.ToString());
				}
				catch (Exception) {}
				ThisException = x;
				ProcessEvent.Set();
				RecalEvent.Set();
			}
		}

		private static bool CheckQuality(SySal.DAQSystem.Scanning.ZoneDesc zd, SySal.Scanning.Plate.IO.OPERA.LinkedZone lz)
		{
			if (zd.MaxX <= zd.MinX || zd.MaxY <= zd.MinY) return true;
			double Area = (zd.MaxX - zd.MinX) * (zd.MaxY - zd.MinY);
			int c, i;
			SySal.Tracking.MIPEmulsionTrackInfo info = null;
			for (i = c = 0; i < lz.Length; i++)
			{
				info = lz[i].Info;
				if (info.Intercept.X >= zd.MinX && info.Intercept.X <= zd.MaxX && info.Intercept.Y >= zd.MinY && info.Intercept.Y <= zd.MaxY) c++;
			}
			if ((c / Area) < ProgSettings.Quality.MinDensityBase) return false;
			return true;
		}

		private static long ReuseZone(SySal.DAQSystem.Scanning.ZoneDesc zd)
		{
			lock(Conn)
			{
				double minx, maxx, miny, maxy, area, reqarea;
				if (zd.MaxX <= zd.MinX || zd.MaxY <= zd.MinY) return 0;
				reqarea = (zd.MaxX - zd.MinX) * (zd.MaxY - zd.MinY);
				string idlist = StartupInfo.ProgramSettingsId.ToString();
				if (ProgSettings.Reuse.ProgramSettingsIds != null)				
					foreach (long id in ProgSettings.Reuse.ProgramSettingsIds)
						idlist += ", " + id.ToString();								
				System.Data.DataSet ds = new System.Data.DataSet();
				new SySal.OperaDb.OperaDbDataAdapter("SELECT ID_ZONE, MINX, MAXX, MINY, MAXY FROM (SELECT /*+INDEX_ASC (TB_VOLUME_SLICES PK_VOLUME_SLICES) */ TB_ZONES.ID AS ID_ZONE, TB_ZONES.MINX, TB_ZONES.MAXX, TB_ZONES.MINY, TB_ZONES.MAXY, TB_ZONES.ID_PROCESSOPERATION AS ID_PROCESSOPERATION, TB_ZONES.ENDTIME AS ENDTIME FROM TB_VOLUME_SLICES INNER JOIN TB_ZONES ON (TB_VOLUME_SLICES.ID_EVENTBRICK = " + StartupInfo.Plate.BrickId + " AND TB_VOLUME_SLICES.ID_PLATE = " + StartupInfo.Plate.PlateId + " AND TB_ZONES.ID_EVENTBRICK = " + StartupInfo.Plate.BrickId + " AND TB_ZONES.ID_PLATE = " + StartupInfo.Plate.PlateId + " AND TB_VOLUME_SLICES.ID_ZONE = TB_ZONES.ID AND TB_VOLUME_SLICES.DAMAGED = 'N')) INNER JOIN TB_PROC_OPERATIONS ON (ID_PROCESSOPERATION = TB_PROC_OPERATIONS.ID) WHERE ID_PROGRAMSETTINGS IN (" + idlist + ") ORDER BY ENDTIME DESC", Conn, Trans).Fill(ds);
				foreach (System.Data.DataRow dr in ds.Tables[0].Rows)
				{
					minx = Math.Max(SySal.OperaDb.Convert.ToDouble(dr[1]), zd.MinX);
					maxx = Math.Min(SySal.OperaDb.Convert.ToDouble(dr[2]), zd.MaxX);
					miny = Math.Max(SySal.OperaDb.Convert.ToDouble(dr[3]), zd.MinY);
					maxy = Math.Min(SySal.OperaDb.Convert.ToDouble(dr[4]), zd.MaxY);
					if (maxx <= minx || maxy <= miny) continue;
					area = (maxx - minx) * (maxy - miny);
					if (area < ProgSettings.Reuse.MinOverlapArea) continue;
					if (area / reqarea < ProgSettings.Reuse.MinOverlapFraction) continue;
					if ((reqarea - area) > ProgSettings.Reuse.MaxMissingArea) continue;
					if (SySal.OperaDb.Convert.ToDouble(new SySal.OperaDb.OperaDbCommand("SELECT COUNT(*) AS NBASE FROM TB_MIPBASETRACKS WHERE ID_EVENTBRICK = " + StartupInfo.Plate.BrickId + " AND ID_ZONE = " + dr[0].ToString() + " AND POSX >= " + zd.MinX.ToString(System.Globalization.CultureInfo.InvariantCulture) + " AND POSX <= " + zd.MaxX.ToString(System.Globalization.CultureInfo.InvariantCulture) + " AND POSY >= " + zd.MinY.ToString(System.Globalization.CultureInfo.InvariantCulture) + " AND POSY <= " + zd.MaxY.ToString(System.Globalization.CultureInfo.InvariantCulture), Conn, Trans).ExecuteScalar()) / reqarea < ProgSettings.Quality.MinDensityBase) continue;
                    SySal.OperaDb.Scanning.Procedures.SetVolumeSliceZone(StartupInfo.Plate.BrickId, (int)StartupInfo.Plate.PlateId, zd.Series, SySal.OperaDb.Convert.ToInt64(dr[0]), 'N', Conn, Trans);
                    //new SySal.OperaDb.OperaDbCommand("CALL PC_SET_VOLUMESLICE_ZONE(" + StartupInfo.Plate.BrickId + ", " + StartupInfo.Plate.PlateId + ", " + zd.Series.ToString() + ", " + dr[0].ToString() + ", 'N')", Conn, Trans).ExecuteNonQuery();
					HE.WriteLine("Reused zone " + dr[0].ToString() + " for " + zd.Series);
					return SySal.OperaDb.Convert.ToInt64(dr[0]);
				}
				return 0;
			}
		}

		private static void WriteResult(SySal.DAQSystem.Drivers.Prediction pred, ScanningResult res, SySal.Scanning.Plate.IO.OPERA.LinkedZone lz)
		{
			try
			{				
				lock(Conn)
				{
					if (pred.CandidateIndex == ScanFailed)
					{
						//new SySal.OperaDb.OperaDbCommand("CALL PC_SET_VOLUMESLICE_ZONE(" + StartupInfo.Plate.BrickId + ", " + StartupInfo.Plate.PlateId + ", " + res.PathId + ", NULL, 'Y')", Conn, Trans).ExecuteNonQuery();
                        SySal.OperaDb.Scanning.Procedures.SetVolumeSliceZone(StartupInfo.Plate.BrickId, (int)StartupInfo.Plate.PlateId, res.PathId, 0, 'Y', Conn, Trans);
					}
					else
					{
						if (lz == null)
						{
							System.IO.FileStream r = new System.IO.FileStream(pred.Outname + ".tlg", System.IO.FileMode.Open, System.IO.FileAccess.Read);
							lz = new SySal.Scanning.Plate.IO.OPERA.LinkedZone(r);
							r.Close();
						}				
						System.DateTime StartTime;
						try
						{
							StartTime = System.IO.File.GetCreationTime(pred.Outname + ".rwc");
						}
						catch (Exception)
						{
							StartTime = System.IO.File.GetCreationTime(pred.Outname + ".tlg").AddSeconds(-1.0);
						}
						long zoneid = SySal.OperaDb.Scanning.LinkedZone.Save(lz, StartupInfo.Plate.BrickId, StartupInfo.Plate.PlateId, StartupInfo.ProcessOperationId, pred.Series, pred.Outname.Substring(pred.Outname.LastIndexOf("\\") + 1), StartTime, System.IO.File.GetCreationTime(pred.Outname + ".tlg"), Conn, Trans);	
						HE.WriteLine("Zone " + zoneid + " Base tracks " + lz.Length);
						//new SySal.OperaDb.OperaDbCommand("CALL PC_SET_VOLUMESLICE_ZONE(" + StartupInfo.Plate.BrickId + ", " + StartupInfo.Plate.PlateId + ", " + res.PathId + ", " + zoneid + ", 'N')", Conn, Trans).ExecuteNonQuery();
                        SySal.OperaDb.Scanning.Procedures.SetVolumeSliceZone(StartupInfo.Plate.BrickId, (int)StartupInfo.Plate.PlateId, res.PathId, zoneid, 'N', Conn, Trans);
					}
				}
			}
			catch(Exception x)
			{
				HE.WriteLine("Exception:\r\n" + x.Message);
				throw x;
			}
		}

		class ForwardComparer : System.Collections.IComparer
		{
			public int Compare(object a, object b)
			{
				double x = ((SySal.DAQSystem.Drivers.Prediction)a).PredictedPosX - ((SySal.DAQSystem.Drivers.Prediction)b).PredictedPosX;
				if (x < 0.0) return -1;
				if (x > 0.0) return 1;
				return 0;
			}
		}

		class BackwardComparer : System.Collections.IComparer
		{
			public int Compare(object a, object b)
			{
				double x = ((SySal.DAQSystem.Drivers.Prediction)a).PredictedPosX - ((SySal.DAQSystem.Drivers.Prediction)b).PredictedPosX;
				if (x > 0.0) return -1;
				if (x < 0.0) return 1;
				return 0;
			}
		}

		static System.Collections.ArrayList OptimizePath(System.Collections.ArrayList p)
		{
			if (p.Count < 3) return p;
			double MinY, MaxY, DY;
			MinY = MaxY = ((Prediction)p[0]).PredictedPosY;
			int i, n;
			for (i = 1; i < p.Count; i++)
			{
				Prediction pred = (Prediction)p[i];
				if (MinY > pred.PredictedPosY) MinY = pred.PredictedPosY;
				else if (MaxY < pred.PredictedPosY) MaxY = pred.PredictedPosY;
			}		
			n = Convert.ToInt32(Math.Sqrt(p.Count) * 0.25 + 1);
			DY = (MaxY - MinY) / n;
			if (DY <= 0.0) DY = 1.0;
			System.Collections.ArrayList [] strips = new System.Collections.ArrayList [n + 1];
			for (i = 0; i <= n; i++)
				strips[i] = new System.Collections.ArrayList();
			System.Collections.IComparer fc = new ForwardComparer();
			System.Collections.IComparer bc = new BackwardComparer();
			foreach (SySal.DAQSystem.Drivers.Prediction pi in p)
			{
				i = Convert.ToInt32((pi.PredictedPosY - MinY) / DY);
				System.Collections.ArrayList s = strips[i];
				int index = s.BinarySearch(pi, ((i % 2) == 0) ? fc : bc);
				if (index < 0) index = ~index;
				s.Insert(index, pi);
			}
			System.Collections.ArrayList np = new System.Collections.ArrayList(p.Count);
			foreach (System.Collections.ArrayList s in strips)
				np.AddRange(s);
			return np;
		}

		static double PathLen(System.Collections.ArrayList p)
		{
			if (p.Count < 2) return 0.0;
			double len = 0.0;
			int i;
			for (i = 1; i < p.Count; i++)
			{
				Prediction p1 = (Prediction)p[i];
				Prediction p2 = (Prediction)p[i - 1];
				len += Math.Max(Math.Abs(p1.PredictedPosX - p2.PredictedPosX), Math.Abs(p1.PredictedPosY - p2.PredictedPosY));
			}
			return len;
		}

		private static void Execute()
		{	
			//HE.WriteLine("Waiting for you");
			//HE.ReadLine();
			ThisThread = System.Threading.Thread.CurrentThread;
			gIm = new System.Drawing.Bitmap(360, 360);
			gMon = System.Drawing.Graphics.FromImage(gIm);
			gPlot = new NumericalTools.Plot();

			StartupInfo = (SySal.DAQSystem.Drivers.ScanningStartupInfo)HE.StartupInfo;
			Conn = new SySal.OperaDb.OperaDbConnection(StartupInfo.DBServers, StartupInfo.DBUserName, StartupInfo.DBPassword);
			Conn.Open();
            (DBKeepAliveThread = new System.Threading.Thread(DBKeepAliveThreadExec)).Start();
			
			if (new SySal.OperaDb.OperaDbCommand("SELECT DAMAGED FROM VW_PLATES WHERE ID_EVENTBRICK = " + StartupInfo.Plate.BrickId + " AND ID = " + StartupInfo.Plate.PlateId, Conn, null).ExecuteScalar().ToString() != "N")
				throw new Exception("Plate #" + StartupInfo.Plate.PlateId + ", Brick #" + StartupInfo.Plate.BrickId + " is damaged!");

			System.Xml.Serialization.XmlSerializer xmls = new System.Xml.Serialization.XmlSerializer(typeof(AreaScan2Settings));
			ProgSettings = (AreaScan2Settings)xmls.Deserialize(new System.IO.StringReader(HE.ProgramSettings));
			xmls = null;

			if (ProgSettings.Recalibration.SelectionText != null)
			{
				ProgSettings.Recalibration.SelectionText = ProgSettings.Recalibration.SelectionText.Replace("&gt;", ">");
				ProgSettings.Recalibration.SelectionText = ProgSettings.Recalibration.SelectionText.Replace("&lt;", "<");
			}
			LinkConfig = (string)new SySal.OperaDb.OperaDbCommand("SELECT SETTINGS FROM TB_PROGRAMSETTINGS WHERE(ID = " + ProgSettings.LinkConfigId + ")", Conn, null).ExecuteScalar();
			LinkerExe = System.Activator.CreateInstanceFrom(StartupInfo.ExeRepository + @"\BatchLink.exe", "SySal.Executables.BatchLink.Exe").Unwrap();
			if (ProgSettings.QualityCutId == ProgSettings.LinkConfigId)
			{
				QualityCut = null;
				QualityCutExe = null;
			}
			else
			{
				QualityCut = (string)new SySal.OperaDb.OperaDbCommand("SELECT SETTINGS FROM TB_PROGRAMSETTINGS WHERE(ID = " + ProgSettings.QualityCutId + ")", Conn, null).ExecuteScalar();
				if (QualityCut.StartsWith("\"") && QualityCut.EndsWith("\"")) QualityCut = QualityCut.Substring(1, QualityCut.Length - 2);
				QualityCutExe = System.Activator.CreateInstanceFrom(StartupInfo.ExeRepository + @"\TLGSel.exe", "SySal.Executables.TLGSel.Exe").Unwrap();
			}
			HE.WriteLine("AreaScan2Driver starting with settings:");
			HE.WriteLine(HE.ProgramSettings);

			if (StartupInfo.ExeRepository.EndsWith("\\")) StartupInfo.ExeRepository = StartupInfo.ExeRepository.Remove(StartupInfo.ExeRepository.Length - 1, 1);
			if (StartupInfo.ScratchDir.EndsWith("\\")) StartupInfo.ScratchDir = StartupInfo.ScratchDir.Remove(StartupInfo.ScratchDir.Length - 1, 1);
			if (StartupInfo.LinkedZonePath.EndsWith("\\")) StartupInfo.LinkedZonePath = StartupInfo.LinkedZonePath.Remove(StartupInfo.LinkedZonePath.Length - 1, 1);
			if (StartupInfo.RawDataPath.EndsWith("\\")) StartupInfo.RawDataPath = StartupInfo.RawDataPath.Remove(StartupInfo.RawDataPath.Length - 1, 1);
			
            lock(Conn)
    			Trans = Conn.BeginTransaction();

			System.Data.DataSet dps = new System.Data.DataSet();
			long parentopid = SySal.OperaDb.Convert.ToInt64(new SySal.OperaDb.OperaDbCommand("SELECT /*+INDEX (TB_PROC_OPERATIONS PK_PROC_OPERATIONS) */ ID_PARENT_OPERATION FROM TB_PROC_OPERATIONS WHERE ID = " + StartupInfo.ProcessOperationId, Conn, null).ExecuteScalar());
			new SySal.OperaDb.OperaDbDataAdapter("SELECT /*+INDEX_ASC (TB_VOLUME_SLICES PK_VOLUME_SLICES) */ ID_VOLUME, MINX, MAXX, MINY, MAXY FROM TB_VOLUME_SLICES INNER JOIN TB_VOLUMES ON (TB_VOLUME_SLICES.ID_EVENTBRICK = TB_VOLUMES.ID_EVENTBRICK AND TB_VOLUME_SLICES.ID_VOLUME = TB_VOLUMES.ID) WHERE ID_ZONE IS NULL AND DAMAGED IS NULL AND ID_PROCESSOPERATION = " + parentopid + " AND TB_VOLUMES.ID_EVENTBRICK = " + StartupInfo.Plate.BrickId + " AND ID_PLATE = " + StartupInfo.Plate.PlateId, Conn, Trans).Fill(dps);
			ProgressInfo = HE.ProgressInfo;
			if (StartupInfo.RecoverFromProgressFile == false)
			{
				TotalZones = dps.Tables[0].Rows.Count;
				ProgressInfo.StartTime = System.DateTime.Now;
				ProgressInfo.FinishTime = ProgressInfo.StartTime;
				ProgressInfo.Progress = 0.0;
				UpdateProgress();
				foreach (System.Data.DataRow dr in dps.Tables[0].Rows)
				{
					SySal.DAQSystem.Drivers.Prediction pred = new SySal.DAQSystem.Drivers.Prediction();
					pred.Series = Convert.ToInt64(dr[0]);
					pred.MinX = Convert.ToDouble(dr[1]);
					pred.MaxX = Convert.ToDouble(dr[2]);
					pred.MinY = Convert.ToDouble(dr[3]);
					pred.MaxY = Convert.ToDouble(dr[4]);
					pred.PredictedPosX = 0.5 * (pred.MinX + pred.MaxX);
					pred.PredictedPosY = 0.5 * (pred.MinY + pred.MaxY);
					pred.PredictedSlopeX = 0;
					pred.PredictedSlopeY = 0;
					pred.MaxTrials = ProgSettings.Quality.MaxTrials;
					pred.Outname = StartupInfo.RawDataPath + "\\areascan_" + StartupInfo.Plate.BrickId + "_" + StartupInfo.Plate.PlateId + "_" + pred.Series;
					ScanQueue.Add(pred);
				}
			}
			else
			{
				try
				{
					XmlDocument xmldoc = new XmlDocument();
					xmldoc.LoadXml(ProgressInfo.CustomInfo.Replace('[','<').Replace(']','>'));
					System.Xml.XmlNode xmlprog = xmldoc.FirstChild;
					RecalibrationDone = Convert.ToBoolean(xmlprog["RecalibrationDone"].InnerText);
					if (RecalibrationDone)
					{
						DirRecal.MXX = Convert.ToDouble(xmlprog["DMXX"].InnerText.ToString(), System.Globalization.CultureInfo.InvariantCulture);
						DirRecal.MXY = Convert.ToDouble(xmlprog["DMXY"].InnerText.ToString(), System.Globalization.CultureInfo.InvariantCulture);
						DirRecal.MYX = Convert.ToDouble(xmlprog["DMYX"].InnerText.ToString(), System.Globalization.CultureInfo.InvariantCulture);
						DirRecal.MYY = Convert.ToDouble(xmlprog["DMYY"].InnerText.ToString(), System.Globalization.CultureInfo.InvariantCulture);
						DirRecal.TX = Convert.ToDouble(xmlprog["DTX"].InnerText.ToString(), System.Globalization.CultureInfo.InvariantCulture);
						DirRecal.TY = Convert.ToDouble(xmlprog["DTY"].InnerText.ToString(), System.Globalization.CultureInfo.InvariantCulture);
						DirRecal.RX = Convert.ToDouble(xmlprog["DRX"].InnerText.ToString(), System.Globalization.CultureInfo.InvariantCulture);
						DirRecal.RY = Convert.ToDouble(xmlprog["DRY"].InnerText.ToString(), System.Globalization.CultureInfo.InvariantCulture);

						InvRecal.MXX = Convert.ToDouble(xmlprog["IMXX"].InnerText.ToString(), System.Globalization.CultureInfo.InvariantCulture);
						InvRecal.MXY = Convert.ToDouble(xmlprog["IMXY"].InnerText.ToString(), System.Globalization.CultureInfo.InvariantCulture);
						InvRecal.MYX = Convert.ToDouble(xmlprog["IMYX"].InnerText.ToString(), System.Globalization.CultureInfo.InvariantCulture);
						InvRecal.MYY = Convert.ToDouble(xmlprog["IMYY"].InnerText.ToString(), System.Globalization.CultureInfo.InvariantCulture);
						InvRecal.TX = Convert.ToDouble(xmlprog["ITX"].InnerText.ToString(), System.Globalization.CultureInfo.InvariantCulture);
						InvRecal.TY = Convert.ToDouble(xmlprog["ITY"].InnerText.ToString(), System.Globalization.CultureInfo.InvariantCulture);
						InvRecal.RX = Convert.ToDouble(xmlprog["IRX"].InnerText.ToString(), System.Globalization.CultureInfo.InvariantCulture);
						InvRecal.RY = Convert.ToDouble(xmlprog["IRY"].InnerText.ToString(), System.Globalization.CultureInfo.InvariantCulture);
					}

					System.Xml.XmlNode xmlelem = xmlprog["Results"];
					XmlNode xn = xmlelem.FirstChild;
					while (xn != null)
					{
						ScanningResult res = new ScanningResult();						
						res.PathId = Convert.ToInt64(xn["PathId"].InnerText);
						res.CandidateId = Convert.ToInt64(xn["CandidateId"].InnerText);
						res.PPX = Convert.ToDouble(xn["PPX"].InnerText, System.Globalization.CultureInfo.InvariantCulture);
						res.PPY = Convert.ToDouble(xn["PPY"].InnerText, System.Globalization.CultureInfo.InvariantCulture);
						res.PSX = Convert.ToDouble(xn["PSX"].InnerText, System.Globalization.CultureInfo.InvariantCulture);
						res.PSY = Convert.ToDouble(xn["PSY"].InnerText, System.Globalization.CultureInfo.InvariantCulture);
						res.DPX = Convert.ToDouble(xn["DPX"].InnerText, System.Globalization.CultureInfo.InvariantCulture);
						res.DPY = Convert.ToDouble(xn["DPY"].InnerText, System.Globalization.CultureInfo.InvariantCulture);
						res.DSX = Convert.ToDouble(xn["DSX"].InnerText, System.Globalization.CultureInfo.InvariantCulture);
						res.DSY = Convert.ToDouble(xn["DSY"].InnerText, System.Globalization.CultureInfo.InvariantCulture);
						ScanningResults.Add(res);
						xn = xn.NextSibling;
					}

					System.Xml.XmlNode xmlzones = xmlprog["RecoverableZones"];
					if (xmlzones != null)
					{
						XmlNode xmlz = xmlzones.FirstChild;
						while (xmlz != null)
						{
							RecoveredZones.Add(Convert.ToInt64(xmlz.InnerText));
							xmlz = xmlz.NextSibling;
						}
					}
					RecoveredZones.Sort();
				}
				catch (Exception)
				{
					RecalibrationDone = false;
				}

				TotalZones = dps.Tables[0].Rows.Count;
				foreach (System.Data.DataRow dr in dps.Tables[0].Rows)
				{
					SySal.DAQSystem.Drivers.Prediction pred = new SySal.DAQSystem.Drivers.Prediction();
					pred.Series = Convert.ToInt64(dr[0]);
					pred.MinX = Convert.ToDouble(dr[1]);
					pred.MaxX = Convert.ToDouble(dr[2]);
					pred.MinY = Convert.ToDouble(dr[3]);
					pred.MaxY = Convert.ToDouble(dr[4]);
					pred.PredictedPosX = 0.5 * (pred.MinX + pred.MaxX);
					pred.PredictedPosY = 0.5 * (pred.MinY + pred.MaxY);
					pred.PredictedSlopeX = 0;
					pred.PredictedSlopeY = 0;
					pred.MaxTrials = ProgSettings.Quality.MaxTrials;
					pred.Outname = StartupInfo.RawDataPath + "\\areascan_" + StartupInfo.Plate.BrickId + "_" + StartupInfo.Plate.PlateId + "_" + pred.Series;
					int i;
					for (i = 0; i < ScanningResults.Count; i++)
						if (((ScanningResult)ScanningResults[i]).PathId == pred.Series)
							break;
					if (i == ScanningResults.Count)
					{
						if (RecoveredZones.BinarySearch(pred.Series) < 0)
						{
							string [] rwds = System.IO.Directory.GetFiles(pred.Outname.Substring(0, pred.Outname.LastIndexOf("\\")), pred.Outname.Substring(pred.Outname.LastIndexOf("\\") + 1) + ".rwd.*");
							foreach (string rwd in rwds)
								try
								{
									System.IO.File.Delete(rwd);
								}
								catch (Exception) {}
							try
							{
								System.IO.File.Delete(pred.Outname + ".rwc");
							}
							catch (Exception) {}
							try
							{
								System.IO.File.Delete(pred.Outname + ".tlg");
							}
							catch (Exception) {}
						}
						ScanQueue.Add(pred);
					}
					else
						WriteResult(pred, (ScanningResult)ScanningResults[i], null);
				}
				UpdatePlots();
			}

			WorkerThread.Start();

            Exe e = new Exe();
            HE.InterruptNotifier = e;
            AppDomain.CurrentDomain.SetData(SySal.DAQSystem.Drivers.HostEnv.WebAccessString, e);        

			/* Recalibration here */

			System.Collections.ArrayList RecalQueue = new System.Collections.ArrayList();
			if (ProgSettings.Recalibration.SelectionText == null || ProgSettings.Recalibration.SelectionText.Trim().Length == 0)
			{
				RecalibrationDone = true;
				DirRecal.MXX = DirRecal.MYY = 1.0;
				DirRecal.MXY = DirRecal.MYX = 0.0;
				DirRecal.TX = DirRecal.TY = DirRecal.TZ = 0.0;
				DirRecal.RX = DirRecal.RY = 0.0;
				InvRecal.MXX = InvRecal.MYY = 1.0;
				InvRecal.MXY = InvRecal.MYX = 0.0;
				InvRecal.TX = InvRecal.TY = InvRecal.TZ = 0.0;
				InvRecal.RX = InvRecal.RY = 0.0;
				MyTransformation.Transformation = InvRecal;
				RecalibrationTracksToScan = 0;
				UpdateProgress();
			}

			if (!RecalibrationDone)
			{
				string recalsql = ProgSettings.Recalibration.SelectionText;
				recalsql = recalsql.Replace("_BRICK_", StartupInfo.Plate.BrickId.ToString()).Replace("_PLATE_", StartupInfo.Plate.PlateId.ToString());
				System.Data.DataSet rds = new System.Data.DataSet();
				new SySal.OperaDb.OperaDbDataAdapter(recalsql, Conn, null).Fill(rds);
				RecalibrationTracksToScan = rds.Tables[0].Rows.Count;
				if (RecalibrationTracksToScan < ProgSettings.Recalibration.MinTracks) throw new Exception("Too few recalibration tracks! " + ProgSettings.Recalibration.MinTracks + " expected, " + rds.Tables[0].Rows.Count + " found.");
				if (rds.Tables[0].Columns.Count != 4) throw new Exception("POSX POSY SLOPEX SLOPEY columns expected, " + rds.Tables[0].Columns + " found!");
					
				System.Data.DataSet bds = new System.Data.DataSet();
				new SySal.OperaDb.OperaDbDataAdapter("SELECT /*+INDEX (TB_EVENTBRICK PK_BRICKS) */ (MINX + MAXX) * 0.5 - ZEROX AS RX, (MINY + MAXY) * 0.5 - ZEROY AS RY FROM TB_EVENTBRICKS WHERE ID = " + StartupInfo.Plate.BrickId, Conn, null).Fill(bds);
				InvRecal.RX = DirRecal.RX = Convert.ToDouble(bds.Tables[0].Rows[0][0]);
				InvRecal.RY = DirRecal.RY = Convert.ToDouble(bds.Tables[0].Rows[0][1]);

				int recalid = 0;
				double minx, miny, maxx, maxy, x, y;
				minx = maxx = Convert.ToDouble(rds.Tables[0].Rows[0][0]);
				miny = maxy = Convert.ToDouble(rds.Tables[0].Rows[0][1]);
				foreach (System.Data.DataRow dr in rds.Tables[0].Rows)
				{
					x = Convert.ToDouble(dr[0]);
					y = Convert.ToDouble(dr[1]);
					if (minx > x) minx = x;
					else if (maxx < x) maxx = x;
					if (miny > y) miny = y;
					else if (maxy < y) maxy = y;

					recalid++;
					SySal.DAQSystem.Drivers.Prediction pred = new SySal.DAQSystem.Drivers.Prediction();
					pred.Series = -recalid;
					pred.PredictedPosX = Convert.ToDouble(dr[0]);
					pred.PredictedPosY = Convert.ToDouble(dr[1]);
					pred.PredictedSlopeX = Convert.ToDouble(dr[2]);
					pred.PredictedSlopeY = Convert.ToDouble(dr[3]);
					pred.MinX = pred.PredictedPosX - ProgSettings.Recalibration.PositionTolerance - 0.5 * ProgSettings.Recalibration.BaseThickness * pred.PredictedSlopeX;
					pred.MaxX = pred.PredictedPosX + ProgSettings.Recalibration.PositionTolerance - 0.5 * ProgSettings.Recalibration.BaseThickness * pred.PredictedSlopeX;
					pred.MinY = pred.PredictedPosY - ProgSettings.Recalibration.PositionTolerance - 0.5 * ProgSettings.Recalibration.BaseThickness * pred.PredictedSlopeY;
					pred.MaxY = pred.PredictedPosY + ProgSettings.Recalibration.PositionTolerance - 0.5 * ProgSettings.Recalibration.BaseThickness * pred.PredictedSlopeY;
					pred.MaxTrials = 1;
					pred.Outname = StartupInfo.RawDataPath + "\\areascan_recal_" + StartupInfo.Plate.BrickId + "_" + StartupInfo.Plate.PlateId + "_" + recalid;

					string [] rwds = System.IO.Directory.GetFiles(pred.Outname.Substring(0, pred.Outname.LastIndexOf("\\")), pred.Outname.Substring(pred.Outname.LastIndexOf("\\") + 1) + ".rwd.*");
					foreach (string rwd in rwds)
						try
						{
							System.IO.File.Delete(rwd);
						}
						catch (Exception) {}
					try
					{
						System.IO.File.Delete(pred.Outname + ".rwc");
					}
					catch (Exception) {}

					RecalQueue.Add(pred);
				}
				if (maxx - minx < ProgSettings.Recalibration.MinXDistance) throw new Exception("Tracks found are too close in X direction!");
				if (maxy - miny < ProgSettings.Recalibration.MinYDistance) throw new Exception("Tracks found are too close in Y direction!");
			}

			/* End recalibration */

			string scanconfig = (string)new SySal.OperaDb.OperaDbCommand("SELECT /*+INDEX (TB_PROGRAMSETTINGS PK_PROGRAMSETTINGS) */ SETTINGS FROM TB_PROGRAMSETTINGS WHERE (ID = " + ProgSettings.ScanningConfigId + ")", Conn, Trans).ExecuteScalar();
			HE.WriteLine("Original path length: " + PathLen(ScanQueue).ToString("F1", System.Globalization.CultureInfo.InvariantCulture));				
			ScanQueue = OptimizePath(ScanQueue);
			HE.WriteLine("Optimized path length: " + PathLen(ScanQueue).ToString("F1", System.Globalization.CultureInfo.InvariantCulture));
			if (ProgSettings.Reuse.Enable)
			{
				while (ScanQueue.Count > 0)
				{
					ReuseQueue.Enqueue(ScanQueue[ScanQueue.Count - 1]);
					ScanQueue.RemoveAt(ScanQueue.Count - 1);
				}
				ScanQueue.InsertRange(0, RecalQueue);
				if (ReuseQueue.Count > 0) WorkerThread.Interrupt();
			}
			else 
			{
				ScanQueue.InsertRange(0, RecalQueue);
				ProcessEvent.Set();
			}


			ProgressInfo.Complete = false;
			ProgressInfo.ExitException = null;
			HE.ProgressInfo = ProgressInfo;

			DataProcSrv = HE.DataProcSrv;
			
			ProcessEvent.WaitOne();
			if (ThisException != null) throw ThisException;

			while (true)
			{					
				if (ScanQueue.Count <= 0) 
				{
                    if (ProgSettings.Quality.MaxTrials <= 1)
                    {
                        HE.ScanSrv = null;
                        ProcessEvent.WaitOne();
                        if (ThisException != null) throw ThisException;
                        break;
                    }
					ProcessEvent.WaitOne();						
					if (ThisException != null) throw ThisException;
					if (ScanQueue.Count <= 0) break;
				}
				Prediction zd = null;
				lock(ScanQueue)
					zd = (Prediction)ScanQueue[0];
				if (zd.Series > 0) 
				{
					if (RecalibrationDone == false)
					{
						RecalEvent.WaitOne();
						if (ThisException != null) throw ThisException;
						if (RecalibrationDone == false) throw new Exception("Recalibration failed!");
					}						
				}
				ProgressInfo.Progress = ((double)TotalZones + RecalQueue.Count - ScanQueue.Count) / ((double)(TotalZones + RecalQueue.Count));
				HE.ProgressInfo = ProgressInfo;
				// UpdateProgress();
				string temp = ReplaceStrings(StartupInfo.RawDataPath + "\\" + zd.Outname, zd.Series, "");
				SySal.DAQSystem.Scanning.ZoneDesc wd = new SySal.DAQSystem.Scanning.ZoneDesc();
				wd.Series = zd.Series;
				if (RecalibrationDone)
				{
					double x = 0.5 * (zd.MinX + zd.MaxX);
					double y = 0.5 * (zd.MinY + zd.MaxY);
					double dx = zd.MaxX - zd.MinX;
					double dy = zd.MaxY - zd.MinY;

					wd.MinX = DirRecal.MXX * (x - DirRecal.RX) + DirRecal.MXY * (y - DirRecal.RY) + DirRecal.TX + DirRecal.RX - 0.5 * dx;
					wd.MinY = DirRecal.MYX * (x - DirRecal.RX) + DirRecal.MYY * (y - DirRecal.RY) + DirRecal.TY + DirRecal.RY - 0.5 * dy;
					wd.MaxX = wd.MinX + dx;
					wd.MaxY = wd.MinY + dy;
				}
				else
				{
					wd.MinX = zd.MinX;
					wd.MinY = zd.MinY;
					wd.MaxX = zd.MaxX;
					wd.MaxY = zd.MaxY;
				}
				wd.Outname = zd.Outname;
				bool usepreload = false;
				SySal.BasicTypes.Rectangle nextrect = new SySal.BasicTypes.Rectangle();
				lock(ScanQueue)
					if (ScanQueue.Count >= 2)
					{
						usepreload = true;
						SySal.DAQSystem.Drivers.Prediction nextp = (SySal.DAQSystem.Drivers.Prediction)ScanQueue[1];
						if (RecalibrationDone)
						{
							double x = 0.5 * (nextp.MinX + nextp.MaxX);
							double y = 0.5 * (nextp.MinY + nextp.MaxY);
							double dx = nextp.MaxX - nextp.MinX;
							double dy = nextp.MaxY - nextp.MinY;

							nextrect.MinX = DirRecal.MXX * (x - DirRecal.RX) + DirRecal.MXY * (y - DirRecal.RY) + DirRecal.TX + DirRecal.RX - 0.5 * dx;
							nextrect.MinY = DirRecal.MYX * (x - DirRecal.RX) + DirRecal.MYY * (y - DirRecal.RY) + DirRecal.TY + DirRecal.RY - 0.5 * dy;
							nextrect.MaxX = nextrect.MinX + dx;
							nextrect.MaxY = nextrect.MinY + dy;
						}
						else
						{
							nextrect.MinX = nextp.MinX;
							nextrect.MinY = nextp.MinY;
							nextrect.MaxX = nextp.MaxX;
							nextrect.MaxY = nextp.MaxY;
						}
					}
                bool check = (RecoveredZones.BinarySearch(wd.Series) >= 0);
                if (check == false)
                {
                    if (ScanSrv == null)
                    {
                        ScanSrv = HE.ScanSrv;
                        if (ScanSrv.SetScanLayout(scanconfig) == false)
                            throw new Exception("Scan Server configuration refused!");
                        if (ScanSrv.LoadPlate(StartupInfo.Plate) == false)
                        {
                            HE.ScanSrv = null;
                            throw new Exception("Can't load plate " + StartupInfo.Plate.PlateId + " + brick " + StartupInfo.Plate.BrickId);
                        }
                    }
                    check = usepreload ? ScanSrv.ScanAndMoveToNext(wd, nextrect) : ScanSrv.Scan(wd);
                }
				if (check)
				{
					lock(ScanQueue)
					{
						ScanQueue.RemoveAt(0);
						WorkQueue.Enqueue(zd);
						if (ProcessEvent.WaitOne(0, false) == true)
						{
							ProcessEvent.Reset();
							WorkerThread.Interrupt();
						}
					}
				}
				else 
				{
					if ((zd.Series < 0 && IgnoreRecalFailure) || (zd.Series >= 0 && IgnoreScanFailure)) 
					{
						zd.CandidateIndex = ScanFailed;
						zd.CandidateInfo = null;
						lock(ScanQueue)
						{
							ScanQueue.RemoveAt(0);
							WorkQueue.Enqueue(zd);
							if (ProcessEvent.WaitOne(0, false) == true)
							{
								ProcessEvent.Reset();
								WorkerThread.Interrupt();
							}
						}
					}
					else throw new Exception("Scanning failed for zone " + zd.Series + " plate " + StartupInfo.Plate.PlateId + " brick " + StartupInfo.Plate.BrickId);
				}
				System.TimeSpan timeelapsed = System.DateTime.Now - ProgressInfo.StartTime;
				ProgressInfo.FinishTime = ProgressInfo.StartTime.AddMilliseconds(timeelapsed.TotalMilliseconds / ((TotalZones + RecalQueue.Count - ScanQueue.Count) + 1) * (TotalZones + RecalQueue.Count));
				UpdateProgress();
			}

			lock(WorkQueue)
			{
				WorkQueue.Clear();
				WorkerThread.Interrupt();
			}
			WorkerThread.Join();

			HE.Progress = 1.0;
			HE.InterruptNotifier = null;
			UpdateProgress();

            lock(Conn)
    			Trans.Commit();			
			ProgressInfo.Complete = true;
			ProgressInfo.ExitException = null;
			ProgressInfo.Progress = 1.0;
			ProgressInfo.FinishTime = System.DateTime.Now;
			UpdateProgress();
            lock (Conn)
            {
                Conn.Close();
                Conn = null;
            }
			UpdatePlots();
		}


		private static string ReplaceStrings(string s, long zoneid, string name)
		{
			string ns = (string)s.Clone();
			ns = ns.Replace("%EXEREP%", StartupInfo.ExeRepository);
			ns = ns.Replace("%RWDDIR%", StartupInfo.RawDataPath);
			ns = ns.Replace("%TLGDIR%", StartupInfo.LinkedZonePath);
			ns = ns.Replace("%SCRATCH%", StartupInfo.ScratchDir);
			ns = ns.Replace("%RWD%", StartupInfo.RawDataPath + name);
			ns = ns.Replace("%TLG%", StartupInfo.LinkedZonePath + name);
			ns = ns.Replace("%ZONEID%", zoneid.ToString("X8"));
			return ns;
		}

		private static System.DateTime NextPlotTime;

		private static void UpdatePlots()
		{
			int i, j;
			int total = 0, scanned = 0, remaining = 0;
			double percent = 0.0;
			total = TotalZones; 
			scanned = TotalZones - ScanQueue.Count;	
			remaining = total - scanned;
			System.DateTime now = System.DateTime.Now;
			if (!IsFirstPlot && now < NextPlotTime) return;			
			NextPlotTime = now.AddSeconds(10.0);
			double [] rx = new double[2];
			string [] cx = new string[2];
			percent = (double)scanned/(double)total * 100.0;
			rx[0] = scanned;
			rx[1] = remaining;
			cx[0] = "Scanned";
			cx[1] = "Remaining";

			try			
			{
				gMon.Clear(System.Drawing.Color.White);
				gPlot.VecX = rx;
				gPlot.CommentX = cx;
				gPlot.SetXDefaultLimits = false;
				gPlot.XTitle = "";
				try
				{
					gPlot.Pie(gMon, gIm.Width, gIm.Height);
					gIm.Save(StartupInfo.ScratchDir + "\\" + StartupInfo.ProcessOperationId + "_00.png", System.Drawing.Imaging.ImageFormat.Png);
				}
				catch (Exception) {}
			}
			catch (Exception) {}

			System.IO.StreamWriter w = null;
			try
			{
				w = new System.IO.StreamWriter(StartupInfo.ScratchDir + "\\" + StartupInfo.ProcessOperationId + "_progress.htm");
				w.WriteLine(
					"<html><head>" + ((scanned < total) ? "<meta http-equiv=\"REFRESH\" content=\"30\">" : "") + "<title>AreaScan2Driver Monitor</title></head><body>\r\n" +
					"<div align=center><p><font face=\"Arial, Helvetica\" size=4 color=4444ff>AreaScan2Driver Brick #" + StartupInfo.Plate.BrickId + ", Plate #" + StartupInfo.Plate.PlateId + "<br>Operation ID = " + StartupInfo.ProcessOperationId + "</font><hr></p></div>\r\n" +
					"<div align=center><p><font face = \"Arial, Helvetica\" size=2 color=0000cc>Total = " + total + "<br>Scanned = " + scanned + "<br>Remaining = " + remaining + " (" + percent.ToString("F1", System.Globalization.CultureInfo.InvariantCulture) + "%)</font></p>\r\n" +
					"<div align=center><p><font face = \"Arial, Helvetica\" size=2 color=000066>IgnoreScanFailure = " + IgnoreScanFailure + "<br>IgnoreRecalFailure = " + IgnoreRecalFailure + "</font></p>\r\n" +
					"<table border=1 align=center>\r\n" +
					"<tr><td><img src=\"" + StartupInfo.ProcessOperationId + "_00.png\" border=0></td></tr></table></div></body></html>"
					);
				w.Flush();
				w.Close();
			}
			catch (Exception) 
			{
				if (w != null) w.Close();
			}
			IsFirstPlot = false;
		}

		private static void UpdateProgress()
		{
			string xmlstr = "\r\n\t\t[InfoContainer]\r\n\t\t\t[RecalibrationDone]" + RecalibrationDone + "[/RecalibrationDone]" + 
				"\r\n\t\t\t[DMXX]" + DirRecal.MXX + "[/DMXX]\r\n\t\t\t[DMXY]" + DirRecal.MXY + "[/DMXY]\r\n\t\t\t[DMYX]" + DirRecal.MYX + "[/DMYX]\r\n\t\t\t[DMYY]" + DirRecal.MYY + "[/DMYY]\r\n\t\t\t[DTX]" + DirRecal.TX + "[/DTX]\r\n\t\t\t[DTY]" + DirRecal.TY + "[/DTY]\r\n\t\t\t[DRX]" + DirRecal.RX + "[/DRX]\r\n\t\t\t[DRY]" + DirRecal.RY + "[/DRY]" +
				"\r\n\t\t\t[IMXX]" + InvRecal.MXX + "[/IMXX]\r\n\t\t\t[IMXY]" + InvRecal.MXY + "[/IMXY]\r\n\t\t\t[IMYX]" + InvRecal.MYX + "[/IMYX]\r\n\t\t\t[IMYY]" + InvRecal.MYY + "[/IMYY]\r\n\t\t\t[ITX]" + InvRecal.TX + "[/ITX]\r\n\t\t\t[ITY]" + InvRecal.TY + "[/ITY]\r\n\t\t\t[IRX]" + InvRecal.RX + "[/IRX]\r\n\t\t\t[IRY]" + InvRecal.RY + "[/IRY]" +
				"\r\n\t\t\t[Results]";
			xmlstr += "[/Results]\r\n\t\t\t[RecoverableZones]\r\n";
			foreach (long z in RecoveredZones)
				xmlstr += "\t\t\t\t[long]" + z + "[/long]\r\n";
			xmlstr += "[/RecoverableZones]\r\n\t\t[/InfoContainer]\r\n";
			ProgressInfo.CustomInfo = xmlstr;
			HE.ProgressInfo = ProgressInfo;
		}

		private static void ComputeRecalibration()
		{
			int valid = 0;
			double minx = 0.0, maxx = 0.0, miny = 0.0, maxy = 0.0;
			foreach (ScanningResult res in RecalibrationResults)			
				if (res.CandidateId > 0)
				{
					if (valid == 0)
					{
						minx = maxx = res.PPX;
						miny = maxy = res.PPY;
					}
					else
					{
						if (minx > res.PPX) minx = res.PPX;
						else if (maxx < res.PPX) maxx = res.PPX;
						if (miny > res.PPY) miny = res.PPY;
						else if (maxy < res.PPY) maxy = res.PPY;
					}
					valid++;
				}			
			if (valid < ProgSettings.Recalibration.MinTracks) throw new Exception("Too few recalibration tracks! " + ProgSettings.Recalibration.MinTracks + " expected, " + valid + " found.");
			if (maxx - minx < ProgSettings.Recalibration.MinXDistance) throw new Exception("Tracks found are too close in X direction!");
			if (maxy - miny < ProgSettings.Recalibration.MinYDistance) throw new Exception("Tracks found are too close in Y direction!");
			double [] PX = new double[valid];
			double [] PY = new double[valid];
			double [] DX = new double[valid];
			double [] DY = new double[valid];
			valid = 0;
			foreach (ScanningResult res in RecalibrationResults)			
				if (res.CandidateId > 0)
				{
					PX[valid] = res.PPX - DirRecal.RX;
					DX[valid] = res.DPX;
					PY[valid] = res.PPY - DirRecal.RY;
					DY[valid] = res.DPY;
					valid++;
				}
			double [] outpar = new double[7];
			NumericalTools.Fitting.Affine(DX, DY, PX, PY, ref outpar);

			DirRecal.MXX = 1.0 + outpar[0];
			DirRecal.MXY = outpar[1];
			DirRecal.MYX = outpar[2];
			DirRecal.MYY = 1.0 + outpar[3];
			DirRecal.TX = outpar[4];
			DirRecal.TY = outpar[5];

			double idet = 1.0 / (DirRecal.MXX * DirRecal.MYY - DirRecal.MXY * DirRecal.MYX);

			InvRecal.MXX = idet * DirRecal.MYY;
			InvRecal.MXY = -idet * DirRecal.MXY;
			InvRecal.MYX = -idet * DirRecal.MYX;
			InvRecal.MYY = idet * DirRecal.MXX;
			InvRecal.TX = (DirRecal.MXY * DirRecal.TY - DirRecal.MYY * DirRecal.TX) * idet;		
			InvRecal.TY = (DirRecal.MYX * DirRecal.TX - DirRecal.MXX * DirRecal.TY) * idet;

			MyTransformation.Transformation = InvRecal;
			RecalibrationDone = true;
			UpdateProgress();
		}

		private static System.Text.RegularExpressions.Regex TwoEx = new System.Text.RegularExpressions.Regex(@"\s*(\S+)\s+(\S+)\s*");

		#region IInterruptNotifier Members

		/// <summary>
		/// Notifies incoming interrupts.
		/// </summary>
		/// <param name="nextint">the next interrupt to be processed.</param>
		public void NotifyInterrupt(Interrupt nextint)
		{
			lock(StartupInfo)
			{
				HE.WriteLine("Processing interrupt string:\n" + nextint.Data);			
				if (nextint.Data != null && nextint.Data.Length > 0)
				{
					string [] lines = nextint.Data.Split(',');
					foreach (string line in lines)
					{
						System.Text.RegularExpressions.Match m = TwoEx.Match(line);
						if (m.Success)
						{
							if (String.Compare(m.Groups[1].Value, "IgnoreScanFailure", true) == 0)
							{
								try
								{
									IgnoreScanFailure = Convert.ToBoolean(m.Groups[2].Value);
									HE.WriteLine("IgnoreScanFailure = " + IgnoreScanFailure);
								}
								catch(Exception){}
							}
							else if (String.Compare(m.Groups[1].Value, "IgnoreRecalFailure", true) == 0)
							{
								try
								{
									IgnoreRecalFailure = Convert.ToBoolean(m.Groups[2].Value);
									HE.WriteLine("IgnoreRecalFailure = " + IgnoreRecalFailure);
								}
								catch(Exception){}
							}						
						}
					}
				}
				HE.LastProcessedInterruptId = nextint.Id;
			}
		}
		#endregion

        #region IWebApplication Members

        public string ApplicationName
        {
            get { return "AreaScan2Driver"; }
        }

        public SySal.Web.ChunkedResponse HttpGet(SySal.Web.Session sess, string page, params string[] queryget)
        {
            return HttpPost(sess, page, queryget);
        }

        const string IgnoreScanFTrue = "ist";
        const string IgnoreScanFFalse = "isf";
        const string IgnoreRecalFTrue = "irt";
        const string IgnoreRecalFFalse = "irf";

        /// <summary>
        /// Processes HTTP POST method calls.
        /// </summary>
        /// <param name="sess">the user session.</param>
        /// <param name="page">the page requested (ignored).</param>
        /// <param name="postfields">commands sent to the page.</param>
        /// <returns>an HTML string with the page to be shown.</returns>
        public SySal.Web.ChunkedResponse HttpPost(SySal.Web.Session sess, string page, params string[] postfields)
        {
            string xctext = null;
            if (postfields != null)
            {
                Interrupt i = new Interrupt();
                i.Id = 0;
                foreach (string s in postfields)
                {
                    if (s.StartsWith(IgnoreRecalFFalse))
                    {
                        i.Data = "IgnoreRecalFailure False";
                    }
                    else if (s.StartsWith(IgnoreRecalFTrue))
                    {
                        i.Data = "IgnoreRecalFailure True";
                    }
                    if (s.StartsWith(IgnoreScanFFalse))
                    {
                        i.Data = "IgnoreScanFailure False";
                    }
                    else if (s.StartsWith(IgnoreScanFTrue))
                    {
                        i.Data = "IgnoreScanFailure True";
                    }
                }
                if (i.Data != null)
                    try
                    {
                        NotifyInterrupt(i);
                    }
                    catch (Exception x)
                    {
                        xctext = x.ToString();
                    }
            }
            string html = "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\r\n" +
                "<html xmlns=\"http://www.w3.org/1999/xhtml\" >\r\n" +
                "<head>\r\n" +
                "    <meta http-equiv=\"pragma\" content=\"no-cache\">\r\n" +
                "    <meta http-equiv=\"EXPIRES\" content=\"0\" />\r\n" +
                "    <title>AreaScan2Driver - " + StartupInfo.Plate.BrickId + "/" + StartupInfo.Plate.PlateId + "/" + StartupInfo.ProcessOperationId + "</title>\r\n" +
                "    <style type=\"text/css\">\r\n" +
                "    th { font-family: Arial,Helvetica; font-size: 12; color: white; background-color: teal; text-align: center; font-weight: bold }\r\n" +
                "    td { font-family: Arial,Helvetica; font-size: 12; color: navy; background-color: white; text-align: right; font-weight: normal }\r\n" +
                "    p {font-family: Arial,Helvetica; font-size: 14; color: black; background-color: white; text-align: left; font-weight: normal }\r\n" +
                "    div {font-family: Arial,Helvetica; font-size: 14; color: black; background-color: white; text-align: center; font-weight: normal }\r\n" +
                "    </style>\r\n" +
                "</head>\r\n" +
                "<body>\r\n" +
                " <div>AreaScan2Driver = " + StartupInfo.ProcessOperationId + "<br>Brick = " + StartupInfo.Plate.BrickId + "<br>Plate = " + StartupInfo.Plate.PlateId + "<br>IgnoreScanFailure = " + IgnoreScanFailure + "<br>IgnoreRecalFailure = " + IgnoreRecalFailure + "</div>\r\n<hr>\r\n" +
                ((xctext != null) ? "<div>Interrupt Error:<br><font color=\"red\">" + SySal.Web.WebServer.HtmlFormat(xctext) + "<font></div>\r\n" : "") +
                " <form action=\"" + page + "\" method=\"post\" enctype=\"application/x-www-form-urlencoded\">\r\n" +
                "  <div>\r\n" +
                "   <input id=\"" + IgnoreRecalFFalse + "\" name=\"" + IgnoreRecalFFalse + "\" type=\"submit\" value=\"Stop on Recal failure\"/>&nbsp;<input id=\"" + IgnoreRecalFTrue + "\" name=\"" + IgnoreRecalFTrue + "\" type=\"submit\" value=\"Ignore Recal failure\"/><br>\r\n" +
                "   <input id=\"" + IgnoreScanFFalse + "\" name=\"" + IgnoreScanFFalse + "\" type=\"submit\" value=\"Stop on Scan failure\"/>&nbsp;<input id=\"" + IgnoreScanFTrue + "\" name=\"" + IgnoreScanFTrue + "\" type=\"submit\" value=\"Ignore Scan failure\"/><br>\r\n" +
                "  </div>\r\n" +
                " </form>\r\n" +
                "</body>\r\n" +
                "</html>";

            return new SySal.Web.HTMLResponse(html);
        }

        public bool ShowExceptions
        {
            get { return true; }
        }

        #endregion
    }
}
